/*
 * This file is part of XUI.
 * Licensed under MIT license.
 */
package net.xmx.xui.core.font;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import net.xmx.xui.core.font.data.MSDFData;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL12;
import org.lwjgl.stb.STBImage;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;

/**
 * Manages the loading and storage of a single font variant (e.g., "Regular" or "Bold").
 * <p>
 * This class is responsible for two primary tasks:
 * <ol>
 *     <li>Parsing the JSON metadata generated by <code>msdf-atlas-gen</code>, which contains
 *     glyph metrics, kerning (advance), and texture coordinates.</li>
 *     <li>Loading the raw PNG texture atlas into OpenGL memory.</li>
 * </ol>
 * <p>
 * <b>Note on Filtering:</b> This class explicitly forces {@code GL_LINEAR} filtering.
 * Multi-channel Signed Distance Fields (MSDF) rely on the GPU's bilinear interpolation
 * to smooth the distance values between texels. Using {@code GL_NEAREST} would result
 * in hard, jagged artifacts and break the MSDF effect.
 * </p>
 *
 * @author xI-Mx-Ix
 */
public class UILoadedFont {

    /**
     * The parsed metadata containing metrics and glyph bounds.
     */
    private final MSDFData fontData;

    /**
     * The OpenGL texture ID handle for the loaded PNG atlas.
     */
    private final int textureId;

    /**
     * Constructs a new font loader and immediately loads resources from the classpath.
     * <p>
     * The method expects two files to exist in the resources folder:
     * <ul>
     *     <li><code>assets/xui/fonts/{name}.json</code></li>
     *     <li><code>assets/xui/fonts/{name}.png</code></li>
     * </ul>
     * </p>
     *
     * @param name The base name of the font file (e.g., "JetBrainsMono-Regular").
     * @throws RuntimeException If the JSON or PNG files cannot be found or parsed.
     */
    public UILoadedFont(String name) {
        String basePath = "/assets/xui/fonts/" + name;

        // -------------------------------------------------------------------------
        // 1. Load and Parse JSON Metadata
        // -------------------------------------------------------------------------
        try (InputStream jsonStream = getClass().getResourceAsStream(basePath + ".json")) {
            if (jsonStream == null) {
                throw new RuntimeException("Font JSON resource not found at path: " + basePath + ".json");
            }

            Gson gson = new Gson();
            JsonObject root = gson.fromJson(new InputStreamReader(jsonStream, StandardCharsets.UTF_8), JsonObject.class);

            // Initialize the data container
            this.fontData = new MSDFData();

            // Deserialize the main sections: 'atlas' info and global 'metrics'
            this.fontData.atlas = gson.fromJson(root.get("atlas"), MSDFData.AtlasInfo.class);
            this.fontData.metrics = gson.fromJson(root.get("metrics"), MSDFData.Metrics.class);

            // Manually parse the 'glyphs' array into a HashMap for O(1) access complexity.
            // This is more efficient than iterating the list during rendering.
            this.fontData.glyphMap = new HashMap<>();
            JsonArray glyphs = root.getAsJsonArray("glyphs");

            for (JsonElement el : glyphs) {
                MSDFData.Glyph g = gson.fromJson(el, MSDFData.Glyph.class);
                this.fontData.glyphMap.put(g.unicode, g);
            }

        } catch (Exception e) {
            throw new RuntimeException("Failed to parse font JSON metadata for: " + name, e);
        }

        // -------------------------------------------------------------------------
        // 2. Load PNG Texture Atlas into OpenGL
        // -------------------------------------------------------------------------
        try (InputStream imgStream = getClass().getResourceAsStream(basePath + ".png")) {
            if (imgStream == null) {
                throw new RuntimeException("Font PNG resource not found at path: " + basePath + ".png");
            }

            // Read the input stream into a byte array
            byte[] bytes = imgStream.readAllBytes();

            // Create a Direct ByteBuffer as required by STB/LWJGL
            ByteBuffer buffer = BufferUtils.createByteBuffer(bytes.length);
            buffer.put(bytes);
            buffer.flip();

            // Buffers to hold image dimensions returned by STB
            IntBuffer w = BufferUtils.createIntBuffer(1);
            IntBuffer h = BufferUtils.createIntBuffer(1);
            IntBuffer c = BufferUtils.createIntBuffer(1);

            // Load image from memory.
            // We force 3 channels (RGB) because MSDF uses R, G, and B for the distance fields.
            // Alpha is generally not used in the MSDF standard.
            ByteBuffer image = STBImage.stbi_load_from_memory(buffer, w, h, c, 3);

            if (image == null) {
                throw new RuntimeException("Failed to load texture via STB: " + STBImage.stbi_failure_reason());
            }

            // Generate OpenGL Texture
            this.textureId = GL11.glGenTextures();
            GL11.glBindTexture(GL11.GL_TEXTURE_2D, textureId);

            // Configure Texture Parameters
            // CRITICAL: MSDF requires Linear filtering to interpolate distances between pixels.
            // Nearest-Neighbor filtering will break the effect and look pixelated.
            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_LINEAR);
            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_LINEAR);

            // Clamp to edge prevents artifacts at the very edge of the texture coordinates
            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);
            GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_T, GL12.GL_CLAMP_TO_EDGE);

            // Upload the texture data to the GPU
            GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGB, w.get(0), h.get(0), 0, GL11.GL_RGB, GL11.GL_UNSIGNED_BYTE, image);

            // Free the CPU-side memory allocated by STB
            STBImage.stbi_image_free(image);

        } catch (Exception e) {
            throw new RuntimeException("Failed to load font texture atlas for: " + name, e);
        }
    }

    /**
     * Gets the OpenGL texture ID for this font's atlas.
     *
     * @return The integer texture handle.
     */
    public int getTextureId() {
        return textureId;
    }

    /**
     * Gets the full metadata object associated with this font.
     *
     * @return The MSDF data containing metrics and atlas info.
     */
    public MSDFData getData() {
        return fontData;
    }

    /**
     * Retrieves the glyph data for a specific Unicode character.
     *
     * @param unicode The integer codepoint of the character.
     * @return The Glyph object if found, or null if the character is not supported.
     */
    public MSDFData.Glyph getGlyph(int unicode) {
        return fontData.glyphMap.get(unicode);
    }
}